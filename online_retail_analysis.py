# -*- coding: utf-8 -*-
"""Online Retail Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Vg380PAmdd2QoSZwT2qFkf2ctUiKc8t
"""

import pandas as pd
import matplotlib.pyplot as plt

"""#### (wget) command is for import zip file from any cloud location"""

!wget https://archive.ics.uci.edu/static/public/352/online+retail.zip

"""#### Unzip file"""

!unzip online+retail.zip



"""#                        Online Retail Analysis

## Dataset description

- The provided dataset represents a comprehensive record of transactions from an online retail business, capturing detailed sales data across various products, customers, and regions. Spanning from December 1, 2010, to December 9, 2011, this dataset includes over 54,1909 entries & 8 columns (based on typical online retail datasets of this nature and the truncated sample provided), documenting purchases and returns made by customers primarily in the United Kingdom, with additional transactions from countries such as France, Germany, and Australia.

- Each row in the dataset corresponds to a line item in an invoice, identified by a unique InvoiceNo, which links multiple products purchased in a single transaction. The StockCode and Description columns catalog the diverse range of products sold, including home decor items (e.g., "WHITE HANGING HEART T-LIGHT HOLDER"), kitchenware (e.g., "JAM MAKING SET WITH JARS"), and novelty goods (e.g., "ALARM CLOCK BAKELIKE RED"), reflecting a business focused on quirky, retro, or handmade retail items. The Quantity column tracks the number of units sold or returned, with negative quantities indicating cancellations or refunds, providing insight into customer satisfaction and return patterns. The InvoiceDate offers a timestamp for each transaction, enabling time-series analysis to uncover seasonal trends, peak sales periods (e.g., Christmas, as seen with items like "PAPER CHAIN KIT 50'S CHRISTMAS"), and daily purchasing behavior. The UnitPrice reflects the cost per item, facilitating revenue calculations and pricing strategy evaluations, while the CustomerID ties transactions to individual buyers, allowing for customer segmentation, loyalty analysis, and repeat purchase tracking. Finally, the Country column highlights the geographical distribution of sales, with the United Kingdom dominating the dataset, suggesting a UK-based retailer with an international reach.

## Columns descriptions

1. **InvoiceNo**:
- **Description**: A unique identifier assigned to each transaction or invoice. It typically consists of a numeric or alphanumeric code that distinguishes one purchase from another. In the dataset, invoice numbers starting with "C" (e.g., "C536379") indicate canceled transactions or returns.
- **Type**: String (alphanumeric).
- **Example**: "536365", "C536379".
---

2. **StockCode**:
- **Description**: A unique code assigned to each product or item available in the inventory. It helps identify the specific product being sold or returned in a transaction.
- **Type**: String (alphanumeric).
- **Example**: "85123A", "71053", "POST" (for postage).
---

3. **Description**:
- **Description**: A textual description of the product associated with the StockCode. It provides details about the item being sold, such as its name, design, or purpose.
- **Type**: String.
- **Example**: "WHITE HANGING HEART T-LIGHT HOLDER", "SET 7 BABUSHKA NESTING BOXES".

---
4. **Quantity**:
- **Description**: The number of units of a specific product purchased or returned in a transaction. Positive values indicate a purchase, while negative values (e.g., "-1", "-12") typically indicate returns or cancellations.
- **Type**: Integer.
- **Example**: 6, -12, 48.

---
5. **InvoiceDate**:
- **Description**: The date and time when the transaction was recorded. It provides temporal context for analyzing sales trends, seasonality, and customer behavior over time.
- **Type**: Datetime (e.g., "2010-12-01 08:26:00").
- **Example**: "2010-12-01 08:26:00", "2011-12-09 12:50:00".
---

6. **UnitPrice**:
- **Description**: The price per unit of the product in the transaction, expressed in the local currency (likely GBP, given the "United Kingdom" dominance in the dataset). It represents the cost of one item before applying discounts or taxes.
- **Type**: Float.
- **Example**: 2.55, 18.00, 0.42.
---

7. **CustomerID**:
- **Description**: A unique identifier for each customer who made the purchase. It allows tracking of individual customer behavior and preferences. Missing values may indicate anonymous or one-time buyers.
- **Type**: Float (with ".0" suffix, though typically treated as an integer identifier).
- **Example**: 17850.0, 13047.0.
---

8. **Country**:
- **Description**: The country where the customer is located or where the transaction was shipped. It provides geographical context for analyzing regional sales patterns.
- **Type**: String.
- **Example**: "United Kingdom", "France", "Australia".
"""



"""## Load dataset"""

df = pd.read_excel("Online Retail.xlsx", dtype = {'InvoiceNo' : 'string', 'StockCode' : 'string', 'Description' : 'string', 'Country' : 'string'})
df.head(3)

df.shape

df.columns

df.info()

"""## Data cleaning
- Handle missing values
"""

df.isnull().sum()



"""### Description column"""

df[df['Description'].isnull()]

df['Description'].mode()

Most_freq = df[['StockCode', 'Description']].value_counts().reset_index()
Most_freq

Most_freq[Most_freq['StockCode']== '85123A'].head(1)

Most_freq = Most_freq.groupby('StockCode').head(1)
Most_freq

# Left merge the Most_freq to df (main dataframe)
Most_freq.columns = ['StockCode','Freq_Description','count']

df1 = df.merge(Most_freq, on = 'StockCode', how = 'left')
df1.head()

df1['Description'] = df1['Freq_Description']
df1.head()

# Check
df1.isnull().sum()

# drop null values from description (Original) column
df1.dropna(subset = ['Description'], inplace = True)

# Check
df1.isnull().sum()

# Drop 'Freq_Description','count' column
df1.drop(columns = ['Freq_Description','count'], inplace = True)

# Check
df1.head()

# Describe
df1.describe()

"""###Quantity and UnitPrice have (Negative) values"""

df1[df1['Quantity'] < 0]

df1[df['UnitPrice'] < 0]

# Create new dataframe
df2 = df1[(df['UnitPrice'] > 0) & (df['Quantity'] > 0)]

df2.describe()



"""## Feature Engineering
- Creating new columns
"""

df3 = df2.copy()

# Creating a new column from Total Sales using Quantity and UnitPrice
df3['Total Sales'] = df3['Quantity'] * df3['UnitPrice']
df3.head(3)

df3.info()

# Create Month column
df3['Month'] = df3['InvoiceDate'].dt.month

df3.head(3)

# Create Day column
df3['Day'] = df3['InvoiceDate'].dt.day_name()

df3.head(3)

# Create Year column
df3['Year'] = df['InvoiceDate'].dt.year

df3.head(3)



"""## Visualize & EDA

### 1. Plot monthly sales
"""

df3['Month'].value_counts()

Monthly_sales = df3.groupby('Month')["Total Sales"].sum()

Monthly_sales.plot(kind = 'line',color = 'green', title = 'Monthly sales', marker = 'o')
plt.xlabel('Month')
plt.ylabel("Total sales")
plt.grid()
plt.show()

"""**Conclusion**
- Total Sales started rising up in August having a peak in November. This is likely due to the holiday season at the end of the year.
"""



"""### 2. Plot Yearly sales"""

df3[['Year', 'Total Sales']].value_counts()

Yearly_sales = df3.groupby('Year')['Total Sales'].sum()

Yearly_sales.plot(kind = 'bar',color = 'blue', title = 'Yearly sales')
plt.xlabel('Year')
plt.ylabel("Total sales")
plt.grid()
plt.show()

"""**Conclusion**
- Total sales graph showing growth period year-by-year for 2010 & 2011.
"""



"""### 3. Top 5 countries by Total sales"""

Top_5_countries = df3.groupby('Country')['Total Sales'].sum().sort_values(ascending = False).head(5)
Top_5_countries

Top_5_countries.plot(kind = 'barh', title = 'Top 5 countries')
plt.xlabel('Total Sales')
plt.ylabel('Countries')
plt.grid(axis = 'x')
plt.show()

"""#### With percentage contribution"""

country_wise_sales = df3.groupby('Country')['Total Sales'].sum()
Total_sales = country_wise_sales.sum()


Top_5_countries = country_wise_sales.sort_values(ascending = False).head(5)
percentage = (Top_5_countries / Total_sales) * 100

plt.figure(figsize = (10, 6))
bars = plt.barh(Top_5_countries.index, percentage)
plt.xlabel('Percentage contribution to Total Sales')
plt.ylabel('Country')
plt.title("Top 5 countries by percentage contribution to Total Sales")
plt.grid(axis = 'x')

# Add percentage label to the bars
for bar, percentage in zip(bars, percentage):
  plt.text(bar.get_width() + 0.5, bar.get_y() + bar.get_height() / 2, f'{percentage:.1f}%', va = 'center')

plt.show()

"""**Conclusion**
- Top 5 countries with their percentage contribution **United Kingdom** have (84.6%) higher percentage contribution as compare to other countries in Total sales.
"""



"""### 4. Top 5 Product categories by Total sales

### Product wise sales
"""

product_wise_sales = df3.groupby('StockCode')['Total Sales'].sum()

Top_5_products = product_wise_sales.sort_values(ascending = False).head(5)
Top_5_products.plot(kind = 'barh', color = 'skyblue')
plt.xlabel('Product Stock Code')
plt.ylabel('Total ales')
plt.title('Product-wise Sales')
plt.gca().invert_yaxis() # To show highest sales at the top
plt.show()

product_wise_sales.sort_values(ascending = False)

df3[df3['StockCode'] == 'DOT']

"""### Products categories"""

for i in Top_5_products.index:
  description = df3[df3['StockCode'] == i].Description.iloc[0]
  print(f"{i} ==> {description}")

"""### With percentage contribution"""

Total_sales = country_wise_sales.sum()
percentage = (Top_5_products / Total_sales) * 100

plt.figure(figsize = (10, 6))
bars = plt.barh(Top_5_products.index, percentage)
plt.xlabel('Percentage contribution to Total Sales')
plt.ylabel('Product Stock Code')
plt.title("Top 5 products by percentage contribution to Total Sales")
plt.grid(axis = 'x')

# Add percentage label to the bars
for bar, percentage in zip(bars, percentage):
  plt.text(bar.get_width() + 0.5, bar.get_y() + bar.get_height() / 2, f'{percentage:.1f}%', va = 'center')

plt.show()

"""**Conclusion**
- Product category **DOT** have (1.9%) higher percentage contribution as compare to other product categories by Total sales
"""



"""### 3. RFM Analysis (Recency, Frequency, Monetary)"""

current_date = df3['InvoiceDate'].max() + pd.Timedelta(days = 1)
current_date

RFM = df3.groupby('CustomerID').agg({
    'InvoiceDate':lambda x: (current_date - x.max()).days,
    'InvoiceNo': "count",
    'Total Sales':"sum"
})

RFM.columns = ['Recency', 'Frequency', 'Monetary']
RFM.head(5)

# From current date to InvoiceDate have (326) days
df3[df3['CustomerID'] == 12346]

# Total sales of particular customerID
df3[df3['CustomerID'] == 12347]['Total Sales'].sum()

"""### Customer Segmentation

- **Recency** = Particular date period time.
- **Frequency** = How many transaction they are making.
- **Monetory** = Total sales based on particular customer.
"""

RFM['R_segment'] = pd.qcut(RFM['Recency'], 4, labels = [4, 3, 2, 1])
RFM['F_segment'] = pd.qcut(RFM['Frequency'], 4, labels = [1, 2, 3, 4])
RFM['M_segment'] = pd.qcut(RFM['Monetary'], 4, labels = [1, 2, 3, 4])
RFM['RFM_score'] = RFM[['R_segment', 'F_segment', 'M_segment']].sum(axis = 1)
RFM

# Customer with highest RFM score (customer which purchase more product)
RFM.sort_values('RFM_score', ascending = False)

"""**Conclusion**
- Customer who have high (R__segment, F_segment,	M_segment) values those are a best customer to generate a revenue.

- These customers get better offers, coupons, discounts, etc., on buying a product.
"""



"""### Customer churn analysis"""

df3.head(3)

# Create a basket matrix for association rule mining
customer_last_purchase = df3.groupby('CustomerID')['InvoiceDate'].max()
customer_last_purchase.head(5)

current_date

customer_last_purchase = (current_date - customer_last_purchase).dt.days
customer_last_purchase.head(5)

# Define chrun threshold (eg :- 90 days without purchase)
churn_threshold = 90
churned_customer = customer_last_purchase[customer_last_purchase> churn_threshold]
churned_customer.head(5)

print("Number of Churned Customers:", len(churned_customer))

plt.figure(figsize = (10, 6))
plt.hist(customer_last_purchase, bins = 50, color = 'red', alpha = 0.7)
plt.axvline(churn_threshold, color = 'black', linestyle = 'dashed', linewidth = 2)
plt.title("Customer churn distribution")
plt.xlabel("Days since last purchase")
plt.ylabel("Number of customers")
plt.show()

"""**Conclusion**
- From mid line we see to right side No. customer who not bought any product within particular days.
- From mid line we see to left side No.customer who bought product within particular days.
"""

